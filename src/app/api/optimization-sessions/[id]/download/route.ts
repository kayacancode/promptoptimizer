import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const cookieStore = await cookies()
    const resolvedParams = await params
    
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get: (name) => cookieStore.get(name)?.value,
        },
      }
    )
    
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Query the session directly using the server client
    console.log('Looking for session ID:', resolvedParams.id)
    console.log('User ID:', user.id)
    
    const { data: session, error: sessionError } = await supabase
      .from('optimization_sessions')
      .select(`
        *,
        optimization_results (*)
      `)
      .eq('id', resolvedParams.id)
      .eq('user_id', user.id)
      .single()
    
    console.log('Found session:', session)
    console.log('Session error:', sessionError)
    
    if (sessionError || !session) {
      console.log('Session not found in database')
      return NextResponse.json({ error: 'Session not found' }, { status: 404 })
    }

    const { searchParams } = new URL(request.url)
    const format = searchParams.get('format') || 'txt'

    if (format === 'json') {
      const exportData = {
        session_info: {
          created_at: session.created_at,
          session_name: session.session_name,
          overall_improvement: session.overall_improvement_percentage
        },
        original_prompt: session.original_prompt,
        requirements: session.requirements_text,
        optimized_prompt: session.optimized_prompt,
        explanation: session.explanation,
        settings_used: session.settings_used,
        model_results: session.optimization_results || []
      }

      const jsonContent = JSON.stringify(exportData, null, 2)
      const filename = `optimization-session-${resolvedParams.id}-${new Date().toISOString().split('T')[0]}.json`
      
      return new NextResponse(jsonContent, {
        headers: {
          'Content-Type': 'application/json',
          'Content-Disposition': `attachment; filename="${filename}"`,
        },
      })
    } else {
      const textContent = `
# Prompt Optimization Session

**Created:** ${new Date(session.created_at!).toLocaleDateString()}
${session.session_name ? `**Session Name:** ${session.session_name}` : ''}
${session.overall_improvement_percentage ? `**Overall Improvement:** +${session.overall_improvement_percentage.toFixed(1)}%` : ''}

## Original Prompt
${session.original_prompt}

## Requirements
${session.requirements_text || 'No specific requirements provided'}

## Optimized Prompt
${session.optimized_prompt}

## Explanation
${session.explanation}

## Settings Used
- Models: ${session.settings_used.modelConfigs.filter(m => m.enabled).map(m => m.name).join(', ')}
- Sample Size: ${session.settings_used.sampleSize}
- Minimum Score: ${session.settings_used.minScore}
- Code Context: ${session.settings_used.codeContextEnabled ? 'Enabled' : 'Disabled'}

${session.optimization_results && session.optimization_results.length > 0 ? `
## Model Results
${session.optimization_results.map(result => `
### ${result.model_name}
- Improvement: ${result.improvement_percentage ? `+${result.improvement_percentage.toFixed(1)}%` : 'N/A'}
- Hallucination Rate: ${result.hallucination_rate ? `${(result.hallucination_rate * 100).toFixed(1)}%` : 'N/A'}
- Structure Score: ${result.structure_score ? `${(result.structure_score * 100).toFixed(1)}%` : 'N/A'}
- Consistency Score: ${result.consistency_score ? `${(result.consistency_score * 100).toFixed(1)}%` : 'N/A'}
`).join('')}` : ''}

---
Generated by bestmate - AI Prompt Optimization Tool
      `.trim()

      const filename = `optimization-session-${resolvedParams.id}-${new Date().toISOString().split('T')[0]}.txt`
      
      return new NextResponse(textContent, {
        headers: {
          'Content-Type': 'text/plain',
          'Content-Disposition': `attachment; filename="${filename}"`,
        },
      })
    }
  } catch (error) {
    console.error('Error downloading optimization session:', error)
    return NextResponse.json(
      { error: 'Failed to download optimization session' },
      { status: 500 }
    )
  }
}